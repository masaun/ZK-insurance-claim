// SPDX-License-Identifier: MIT
pragma solidity ^0.8.29;

import { InsuranceClaimProofVerifier } from "./circuit/InsuranceClaimProofVerifier.sol"; // generated by Noir/Groth16
import { InsuranceClaimRegistry } from "./InsuranceClaimRegistry.sol"; // generated by Noir/Groth16
import { Events } from "./libraries/Events.sol";


/**
 * @title - InsuranceClaim contract
 * @dev - This contract is used by patients to submit insurance claims with zkSNARK proofs.
 */
contract InsuranceClaim {
    InsuranceClaimProofVerifier public insuranceClaimProofVerifier;
    InsuranceClaimRegistry public insuranceClaimRegistry;

    mapping(bytes32 => bool) private nullifiers;
    mapping(address => mapping(bytes32 => bool)) public hasClaimed;

    constructor(InsuranceClaimProofVerifier _insuranceClaimProofVerifier, InsuranceClaimRegistry _insuranceClaimRegistry) {
        insuranceClaimProofVerifier = _insuranceClaimProofVerifier;
        insuranceClaimRegistry = _insuranceClaimRegistry;
    }

    /**
     * @notice - This caller must be a patient (insured)
     * @notice - Submit a insurance claim with a zkSNARK proof
     */
    function submitInsuranceClaim(
        bytes calldata proof, 
        bytes32[] calldata publicInputs
    ) external {
        // @dev - Verify the zkSNARK proof
        bytes32[] memory publicInputs = new bytes32[](4);
        bytes32 merkleRoot = publicInputs[0];
        bytes32 nullifierHash = publicInputs[1];
        bytes32 hospitalPubKeyHash = publicInputs[2];  // [TODO]: Set as a publicInput in ZK circuit
        bytes32 insurerPubKeyHash = publicInputs[3];   // [TODO]: Set as a publicInput in ZK circuit
        bool isValidProof = insuranceClaimProofVerifier.verifyInsuranceClaimProof(proof, publicInputs);
        require(isValidProof, "Invalid proof");

        // @dev - [TODO]: Check a signature of the hospital and the insurer - by comparing the hashed-signature with the publicInputs[2] (hospitalSignature)
        address hospitalPubKey;  // [TODO]: Set an appropreate pubKey-retrieved from a publicInput (= "hospitalPubKeyHash")
        address insurerPubKey;   // [TODO]: Set an appropreate pubKey-retrieved from a publicInput (= "insurerPubKeyHash")
        require(insuranceClaimRegistry.isHospitalPubkeyRegistered(hospitalPubKey), "This hospital pubKey has not registered");
        require(insuranceClaimRegistry.isInsurerPubkeyRegistered(insurerPubKey), "This insurer pubKey has not registered");

        // @dev - Store the claimed-status of the claimant (msg.sender). NOTE: This claimant is a "patient".
        require(!hasClaimed[msg.sender][merkleRoot], "Already claimed");
        hasClaimed[msg.sender][merkleRoot] = true;

        // @dev - Store the nullifierHash to prevent a double spending of proof.
        nullifiers[nullifierHash] = true;

        // @dev - Send payout
        uint256 payoutAmount = _proceedPayout();

        emit Events.ClaimApproved(msg.sender, payoutAmount);
    }

    /**
     * @notice - This function is called to send the payout to the claimant
     */
    function _proceedPayout() internal returns (uint256 _payoutAmount) {
        // @dev - Send payout
        uint256 payoutAmount = 1 ether;
        payable(msg.sender).transfer(payoutAmount);

        emit Events.PayoutProcessed(msg.sender, payoutAmount);
        return payoutAmount;
    }



    // Fallback function to receive ETH for payouts
    receive() external payable {}
}
