// SPDX-License-Identifier: MIT
pragma solidity ^0.8.29;

import { InsuranceClaimProofVerifier } from "./circuit/InsuranceClaimProofVerifier.sol"; // generated by Noir/Groth16

contract InsuranceClaim {
    InsuranceClaimProofVerifier public insuranceClaimProofVerifier;
    address public insurer;

    mapping(address => bool) public hasClaimed;

    event ClaimApproved(address indexed claimant, uint256 payout);

    constructor(address _insuranceClaimProofVerifier) {
        insuranceClaimProofVerifier = InsuranceClaimProofVerifier(_insuranceClaimProofVerifier);
        insurer = msg.sender;
    }

    /**
     * @notice - Submit a claim with a zkSNARK proof
     */
    function submitClaim(
        bytes calldata proof, 
        bytes32[] calldata publicInputs
    ) external {
        require(!hasClaimed[msg.sender], "Already claimed");

        // @dev - Verify the zkSNARK proof
        bool isValidProof = insuranceClaimProofVerifier.verifyInsuranceClaimProof(proof, publicInputs);
        require(isValidProof, "Invalid proof");

        // @dev - [TODO]: Check that result == 1 (claim conditions met)
        //require(publicInputs.result == 1, "Claim requirements not met");

        hasClaimed[msg.sender] = true;

        // @dev - Send payout
        uint256 payoutAmount = 1 ether;
        payable(msg.sender).transfer(payoutAmount);

        emit ClaimApproved(msg.sender, payoutAmount);
    }

    // Fallback function to receive ETH for payouts
    receive() external payable {}
}
