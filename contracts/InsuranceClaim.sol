// SPDX-License-Identifier: MIT
pragma solidity ^0.8.29;

import { InsuranceClaimProofVerifier } from "./circuit/InsuranceClaimProofVerifier.sol"; // generated by Noir/Groth16
import { Events } from "./libraries/Events.sol";

contract InsuranceClaim {
    InsuranceClaimProofVerifier public insuranceClaimProofVerifier;
    address public insurer;

    mapping(bytes32 => bool) private nullifiers;
    mapping(address => mapping(bytes32 => bool)) public hasClaimed;

    constructor(address _insuranceClaimProofVerifier) {
        insuranceClaimProofVerifier = InsuranceClaimProofVerifier(_insuranceClaimProofVerifier);
        insurer = msg.sender;
    }

    /**
     * @notice - This caller must be the Hospital (System)
     * @notice - Store some info from a publicOutput, which was generated when a ZKP was proved.
     */
    // function storeHospitalBillData(
    //     bytes calldata proof, 
    //     bytes32[] calldata publicInputs
    // ) external {
    //     // [TODO]:
    // }


    /**
     * @notice - This caller must be the insurer (= Patient)
     * @notice - Submit a insurance claim with a zkSNARK proof
     */
    function submitInsuranceClaim(
        bytes calldata proof, 
        bytes32[] calldata publicInputs
    ) external {
        require(!hasClaimed[msg.sender], "Already claimed");

        // @dev - Verify the zkSNARK proof
        bytes32[] memory publicInputs = new bytes32[](3);
        bytes32 merkleRoot = publicInputs[0];
        bytes32 nullifierHash = publicInputs[1];
        bool isValidProof = insuranceClaimProofVerifier.verifyInsuranceClaimProof(proof, publicInputs);
        require(isValidProof, "Invalid proof");

        // @dev - [TODO]: Check a signature of the hospital and the insurer - by comparing the hashed-signature with the publicInputs[2] (hospitalSignature)

        // @dev - Store the claimed-status of the claimant (msg.sender). NOTE: This claimant is a "patient".
        hasClaimed[msg.sender][merkleRoot] = true;

        // @dev - Store the nullifierHash to prevent a double spending of proof.
        nullifiers[nullifierHash] = true;

        // @dev - Send payout
        uint256 payoutAmount = _proceedPayout();

        emit Events.ClaimApproved(msg.sender, payoutAmount);
    }

    /**
     * @notice - This function is called to send the payout to the claimant
     */
    function _proceedPayout() internal returns (uint256 _payoutAmount) {
        // @dev - Send payout
        uint256 payoutAmount = 1 ether;
        payable(msg.sender).transfer(payoutAmount);

        emit Events.PayoutProcessed(msg.sender, payoutAmount);
        return payoutAmount;
    }



    // Fallback function to receive ETH for payouts
    receive() external payable {}
}
